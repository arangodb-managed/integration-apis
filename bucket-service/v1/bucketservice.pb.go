// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bucketservice.proto

package v1

import (
	context "context"
	fmt "fmt"
	v11 "github.com/arangodb-managed/apis/common/v1"
	v1 "github.com/arangodb-managed/integration-apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request params for Bucket related calls
type BucketRequest struct {
	// Key-value pairs stored at the providers (as labels/tags) during CreateBucket
	Tags                 []*v1.KeyValuePair `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BucketRequest) Reset()         { *m = BucketRequest{} }
func (m *BucketRequest) String() string { return proto.CompactTextString(m) }
func (*BucketRequest) ProtoMessage()    {}
func (*BucketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{0}
}
func (m *BucketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketRequest.Merge(m, src)
}
func (m *BucketRequest) XXX_Size() int {
	return m.Size()
}
func (m *BucketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BucketRequest proto.InternalMessageInfo

func (m *BucketRequest) GetTags() []*v1.KeyValuePair {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Request params for Path related requests
type PathRequest struct {
	// The path (Specify as "." to indicate the root folder)
	Path                 string   `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathRequest) Reset()         { *m = PathRequest{} }
func (m *PathRequest) String() string { return proto.CompactTextString(m) }
func (*PathRequest) ProtoMessage()    {}
func (*PathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{1}
}
func (m *PathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathRequest.Merge(m, src)
}
func (m *PathRequest) XXX_Size() int {
	return m.Size()
}
func (m *PathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PathRequest proto.InternalMessageInfo

func (m *PathRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Response from GetRepositoryURL request
type RepositoryURL struct {
	// The URL
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The URL without provider information
	BucketPath           string   `protobuf:"bytes,2,opt,name=bucket_path,json=bucketPath,proto3" json:"bucket_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepositoryURL) Reset()         { *m = RepositoryURL{} }
func (m *RepositoryURL) String() string { return proto.CompactTextString(m) }
func (*RepositoryURL) ProtoMessage()    {}
func (*RepositoryURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{2}
}
func (m *RepositoryURL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepositoryURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepositoryURL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepositoryURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepositoryURL.Merge(m, src)
}
func (m *RepositoryURL) XXX_Size() int {
	return m.Size()
}
func (m *RepositoryURL) XXX_DiscardUnknown() {
	xxx_messageInfo_RepositoryURL.DiscardUnknown(m)
}

var xxx_messageInfo_RepositoryURL proto.InternalMessageInfo

func (m *RepositoryURL) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *RepositoryURL) GetBucketPath() string {
	if m != nil {
		return m.BucketPath
	}
	return ""
}

// Response from GetPathSize request
type PathSize struct {
	// The size in bytes
	SizeInBytes uint64 `protobuf:"varint,1,opt,name=size_in_bytes,json=sizeInBytes,proto3" json:"size_in_bytes,omitempty"`
	// Number of files
	NumberOfFiles uint32 `protobuf:"varint,2,opt,name=number_of_files,json=numberOfFiles,proto3" json:"number_of_files,omitempty"`
	// Number of folders
	NumberOfFolders      uint32   `protobuf:"varint,3,opt,name=number_of_folders,json=numberOfFolders,proto3" json:"number_of_folders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathSize) Reset()         { *m = PathSize{} }
func (m *PathSize) String() string { return proto.CompactTextString(m) }
func (*PathSize) ProtoMessage()    {}
func (*PathSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{3}
}
func (m *PathSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathSize.Merge(m, src)
}
func (m *PathSize) XXX_Size() int {
	return m.Size()
}
func (m *PathSize) XXX_DiscardUnknown() {
	xxx_messageInfo_PathSize.DiscardUnknown(m)
}

var xxx_messageInfo_PathSize proto.InternalMessageInfo

func (m *PathSize) GetSizeInBytes() uint64 {
	if m != nil {
		return m.SizeInBytes
	}
	return 0
}

func (m *PathSize) GetNumberOfFiles() uint32 {
	if m != nil {
		return m.NumberOfFiles
	}
	return 0
}

func (m *PathSize) GetNumberOfFolders() uint32 {
	if m != nil {
		return m.NumberOfFolders
	}
	return 0
}

// Response from GetObjectInfo request
type ObjectInfo struct {
	// Indicates if the object is locked
	IsLocked bool `protobuf:"varint,1,opt,name=is_locked,json=isLocked,proto3" json:"is_locked,omitempty"`
	// Indicates the size of the object in bytes
	SizeInBytes uint64 `protobuf:"varint,2,opt,name=size_in_bytes,json=sizeInBytes,proto3" json:"size_in_bytes,omitempty"`
	// The timestamp this object has last been modified
	LastUpdatedAt        *types.Timestamp `protobuf:"bytes,3,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ObjectInfo) Reset()         { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()    {}
func (*ObjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{4}
}
func (m *ObjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectInfo.Merge(m, src)
}
func (m *ObjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ObjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectInfo proto.InternalMessageInfo

func (m *ObjectInfo) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *ObjectInfo) GetSizeInBytes() uint64 {
	if m != nil {
		return m.SizeInBytes
	}
	return 0
}

func (m *ObjectInfo) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

// Output message for ReadObject.
type ReadObjectChunk struct {
	// Raw output
	Chunk                []byte   `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadObjectChunk) Reset()         { *m = ReadObjectChunk{} }
func (m *ReadObjectChunk) String() string { return proto.CompactTextString(m) }
func (*ReadObjectChunk) ProtoMessage()    {}
func (*ReadObjectChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{5}
}
func (m *ReadObjectChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadObjectChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadObjectChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadObjectChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadObjectChunk.Merge(m, src)
}
func (m *ReadObjectChunk) XXX_Size() int {
	return m.Size()
}
func (m *ReadObjectChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadObjectChunk.DiscardUnknown(m)
}

var xxx_messageInfo_ReadObjectChunk proto.InternalMessageInfo

func (m *ReadObjectChunk) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// Input message for WriteObject
type WriteObjectChunk struct {
	// Base request params for Path related requests.
	// This field cannot change during the stream.
	Path *PathRequest `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Raw input
	Chunk []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
	// If set, the caller wants to send a next message with more input data.
	// If not set, no more control message will be sent.
	HasMore              bool     `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteObjectChunk) Reset()         { *m = WriteObjectChunk{} }
func (m *WriteObjectChunk) String() string { return proto.CompactTextString(m) }
func (*WriteObjectChunk) ProtoMessage()    {}
func (*WriteObjectChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{6}
}
func (m *WriteObjectChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteObjectChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteObjectChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteObjectChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteObjectChunk.Merge(m, src)
}
func (m *WriteObjectChunk) XXX_Size() int {
	return m.Size()
}
func (m *WriteObjectChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteObjectChunk.DiscardUnknown(m)
}

var xxx_messageInfo_WriteObjectChunk proto.InternalMessageInfo

func (m *WriteObjectChunk) GetPath() *PathRequest {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *WriteObjectChunk) GetChunk() []byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *WriteObjectChunk) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

// Output message for WriteObject
type WriteObjectControl struct {
	// If set, the next chunk of input is allowed.
	// If unset, the caller is expected to terminate the call.
	AllowMoreOutput bool `protobuf:"varint,1,opt,name=allow_more_output,json=allowMoreOutput,proto3" json:"allow_more_output,omitempty"`
	// Maximum number of bytes the caller is allowed to send in the next input chunk.
	MaxChunkBytes        int32    `protobuf:"varint,2,opt,name=max_chunk_bytes,json=maxChunkBytes,proto3" json:"max_chunk_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteObjectControl) Reset()         { *m = WriteObjectControl{} }
func (m *WriteObjectControl) String() string { return proto.CompactTextString(m) }
func (*WriteObjectControl) ProtoMessage()    {}
func (*WriteObjectControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a66cea33bcc7db8, []int{7}
}
func (m *WriteObjectControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteObjectControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteObjectControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteObjectControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteObjectControl.Merge(m, src)
}
func (m *WriteObjectControl) XXX_Size() int {
	return m.Size()
}
func (m *WriteObjectControl) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteObjectControl.DiscardUnknown(m)
}

var xxx_messageInfo_WriteObjectControl proto.InternalMessageInfo

func (m *WriteObjectControl) GetAllowMoreOutput() bool {
	if m != nil {
		return m.AllowMoreOutput
	}
	return false
}

func (m *WriteObjectControl) GetMaxChunkBytes() int32 {
	if m != nil {
		return m.MaxChunkBytes
	}
	return 0
}

func init() {
	proto.RegisterType((*BucketRequest)(nil), "arangodb.cloud.integration.bucketservice.v1.BucketRequest")
	proto.RegisterType((*PathRequest)(nil), "arangodb.cloud.integration.bucketservice.v1.PathRequest")
	proto.RegisterType((*RepositoryURL)(nil), "arangodb.cloud.integration.bucketservice.v1.RepositoryURL")
	proto.RegisterType((*PathSize)(nil), "arangodb.cloud.integration.bucketservice.v1.PathSize")
	proto.RegisterType((*ObjectInfo)(nil), "arangodb.cloud.integration.bucketservice.v1.ObjectInfo")
	proto.RegisterType((*ReadObjectChunk)(nil), "arangodb.cloud.integration.bucketservice.v1.ReadObjectChunk")
	proto.RegisterType((*WriteObjectChunk)(nil), "arangodb.cloud.integration.bucketservice.v1.WriteObjectChunk")
	proto.RegisterType((*WriteObjectControl)(nil), "arangodb.cloud.integration.bucketservice.v1.WriteObjectControl")
}

func init() { proto.RegisterFile("bucketservice.proto", fileDescriptor_4a66cea33bcc7db8) }

var fileDescriptor_4a66cea33bcc7db8 = []byte{
	// 797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xc7, 0xbb, 0x5b, 0xc8, 0xbe, 0xac, 0x95, 0x65, 0x40, 0xb0, 0x04, 0x29, 0x6d, 0x7d, 0x80,
	0x15, 0x68, 0xed, 0x26, 0x08, 0x81, 0xf8, 0xab, 0xa6, 0xb4, 0xab, 0x15, 0x0b, 0x89, 0xbc, 0xb4,
	0x15, 0x5c, 0xac, 0xb1, 0xfd, 0xe2, 0x0c, 0xb1, 0x3d, 0x66, 0x66, 0x1c, 0x36, 0x3d, 0x70, 0xe8,
	0x01, 0x71, 0xed, 0x8d, 0xef, 0xc3, 0x85, 0x23, 0x1f, 0x01, 0x2d, 0x5f, 0x04, 0x79, 0x26, 0x21,
	0x4e, 0x2b, 0xba, 0x4a, 0x56, 0xea, 0xed, 0xf9, 0xcd, 0x7b, 0xbf, 0xdf, 0xef, 0xbd, 0x37, 0xf3,
	0x12, 0x78, 0x2d, 0x2c, 0xa3, 0x09, 0x2a, 0x89, 0x62, 0xca, 0x22, 0x74, 0x0b, 0xc1, 0x15, 0x27,
	0xef, 0x53, 0x41, 0xf3, 0x84, 0xc7, 0xa1, 0x1b, 0xa5, 0xbc, 0x8c, 0x5d, 0x96, 0x2b, 0x4c, 0x04,
	0x55, 0x8c, 0xe7, 0xee, 0x6a, 0xfc, 0xb4, 0xdb, 0x7e, 0x23, 0xe2, 0x59, 0xc6, 0x73, 0x6f, 0xda,
	0xf5, 0x8c, 0x65, 0x40, 0xda, 0x6f, 0x2e, 0xfd, 0x6c, 0xe5, 0xe0, 0xd3, 0x84, 0xa9, 0x71, 0x19,
	0xba, 0x11, 0xcf, 0xbc, 0x84, 0xa7, 0x34, 0x4f, 0x3c, 0x7d, 0x10, 0x96, 0x23, 0xaf, 0x50, 0xb3,
	0x02, 0xa5, 0xa7, 0x58, 0x86, 0x52, 0xd1, 0xac, 0x58, 0x5a, 0x26, 0xd9, 0x79, 0x08, 0x76, 0x5f,
	0x2b, 0xf0, 0xf1, 0xa7, 0x12, 0xa5, 0x22, 0xf7, 0x60, 0x47, 0xd1, 0x44, 0x1e, 0xc0, 0x8d, 0xed,
	0xc3, 0x66, 0xaf, 0xe7, 0x3e, 0x47, 0xfa, 0x5c, 0xc5, 0xb4, 0xeb, 0x7e, 0x8d, 0xb3, 0x07, 0x34,
	0x2d, 0x71, 0x48, 0x99, 0xf0, 0x75, 0xbe, 0x73, 0x13, 0x9a, 0x43, 0xaa, 0xc6, 0x0b, 0x58, 0x02,
	0x3b, 0x05, 0x55, 0xe3, 0x83, 0xed, 0x1b, 0xd6, 0xe1, 0xae, 0xaf, 0x6d, 0xa7, 0x0f, 0xb6, 0x8f,
	0x05, 0x97, 0x4c, 0x71, 0x31, 0xbb, 0xef, 0x9f, 0x92, 0x7d, 0xd8, 0x2e, 0x45, 0x7a, 0x60, 0xe9,
	0x98, 0xca, 0x24, 0xd7, 0xa1, 0x69, 0x1a, 0x14, 0xe8, 0xec, 0x2d, 0x7d, 0x02, 0xc6, 0x55, 0xc1,
	0x3b, 0x8f, 0x2d, 0x68, 0x54, 0xc6, 0x19, 0x7b, 0x84, 0xc4, 0x01, 0x5b, 0xb2, 0x47, 0x18, 0xb0,
	0x3c, 0x08, 0x67, 0x0a, 0xa5, 0x46, 0xda, 0xf1, 0x9b, 0x95, 0xf3, 0x24, 0xef, 0x57, 0x2e, 0xf2,
	0x0e, 0xb4, 0xf2, 0x32, 0x0b, 0x51, 0x04, 0x7c, 0x14, 0x8c, 0x58, 0x8a, 0x52, 0xa3, 0xda, 0xbe,
	0x6d, 0xdc, 0x83, 0xd1, 0xbd, 0xca, 0x49, 0xde, 0x83, 0x57, 0x6b, 0x71, 0x3c, 0x8d, 0x51, 0x48,
	0xad, 0xde, 0xf6, 0x5b, 0xff, 0x45, 0x1a, 0xb7, 0xf3, 0xc4, 0x02, 0x18, 0x84, 0x3f, 0x62, 0xa4,
	0x4e, 0xf2, 0x11, 0x27, 0x6f, 0xc3, 0x2e, 0x93, 0x41, 0xca, 0xa3, 0x09, 0xc6, 0x5a, 0x42, 0xc3,
	0x6f, 0x30, 0x79, 0xaa, 0xbf, 0x9f, 0xd5, 0xb8, 0xf5, 0xac, 0xc6, 0x3e, 0xb4, 0x52, 0x2a, 0x55,
	0x50, 0x16, 0x31, 0x55, 0x18, 0x07, 0x54, 0x69, 0xe6, 0x66, 0xaf, 0xed, 0x26, 0x9c, 0x27, 0xe9,
	0xfc, 0x5e, 0x85, 0xe5, 0xc8, 0xfd, 0x6e, 0x31, 0x4f, 0xdf, 0xae, 0x52, 0xee, 0x9b, 0x8c, 0xdb,
	0xca, 0x79, 0x17, 0x5a, 0x3e, 0xd2, 0xd8, 0xc8, 0xba, 0x33, 0x2e, 0xf3, 0x09, 0x79, 0x1d, 0xae,
	0x45, 0x95, 0xa1, 0x35, 0xed, 0xf9, 0xe6, 0xa3, 0x12, 0xbf, 0xff, 0x50, 0x30, 0x85, 0xf5, 0xd0,
	0xd3, 0xf9, 0xb8, 0x2c, 0x4d, 0xfb, 0xb1, 0xbb, 0xc6, 0x05, 0x76, 0x6b, 0x63, 0x37, 0x83, 0x5e,
	0x12, 0x6f, 0xd5, 0x88, 0xc9, 0x5b, 0xd0, 0x18, 0x53, 0x19, 0x64, 0x5c, 0xa0, 0x2e, 0xaf, 0xe1,
	0xbf, 0x32, 0xa6, 0xf2, 0x1b, 0x2e, 0xd0, 0x19, 0x03, 0xa9, 0x4b, 0xe2, 0xb9, 0x12, 0x3c, 0xad,
	0x46, 0x42, 0xd3, 0x94, 0xff, 0xac, 0x53, 0x02, 0x5e, 0xaa, 0xa2, 0x54, 0xf3, 0xfe, 0xb6, 0xf4,
	0x41, 0x95, 0x3b, 0xd0, 0xee, 0x6a, 0xcc, 0x19, 0x3d, 0x0f, 0x34, 0x53, 0xad, 0xd1, 0xd7, 0x7c,
	0x3b, 0xa3, 0xe7, 0xba, 0x46, 0xdd, 0xea, 0xde, 0x1f, 0xbb, 0x8b, 0x07, 0x70, 0x66, 0x2a, 0x20,
	0x67, 0x60, 0x1f, 0xa3, 0xba, 0x3d, 0x3c, 0x79, 0x80, 0x42, 0x32, 0x9e, 0x93, 0xeb, 0x4f, 0x57,
	0xbf, 0xbc, 0xf7, 0x77, 0xb3, 0x42, 0xcd, 0xda, 0x37, 0xff, 0x3f, 0x60, 0x81, 0x91, 0xc1, 0x9e,
	0x61, 0xb9, 0x7b, 0xce, 0xa4, 0x92, 0xe4, 0x93, 0xb5, 0x3a, 0xba, 0xf2, 0x42, 0x9f, 0x47, 0xf7,
	0x3d, 0xca, 0x81, 0xf8, 0x96, 0x93, 0x09, 0xec, 0xdd, 0x11, 0x48, 0x15, 0x9a, 0xcc, 0x2b, 0xd1,
	0x5d, 0x56, 0x7e, 0x45, 0xf6, 0x15, 0xa6, 0xf8, 0x62, 0xc8, 0x7e, 0xb3, 0x60, 0xff, 0xb8, 0x8a,
	0xaf, 0xef, 0x8d, 0x8d, 0xef, 0x67, 0x7b, 0x3d, 0xad, 0xab, 0xac, 0x09, 0x80, 0xa9, 0xbb, 0x02,
	0xbc, 0x82, 0x86, 0x4b, 0x6b, 0xfe, 0x05, 0x9a, 0xc7, 0x66, 0xdd, 0xe9, 0x2d, 0xb7, 0x39, 0xd3,
	0x87, 0x6b, 0x67, 0x6a, 0xc2, 0x5f, 0x2d, 0x80, 0xe5, 0x2e, 0xb9, 0x02, 0xff, 0x67, 0x6b, 0x76,
	0x7b, 0x65, 0x7d, 0xdd, 0xb2, 0xc8, 0x13, 0x0b, 0x9a, 0xb5, 0xbd, 0x40, 0x3e, 0x5f, 0x0b, 0xef,
	0xe9, 0x25, 0xd7, 0xfe, 0x72, 0xe3, 0x74, 0xb3, 0x90, 0x0e, 0xad, 0x5b, 0x16, 0x79, 0x6c, 0xe9,
	0x7d, 0x51, 0x5b, 0xff, 0x9b, 0xf7, 0xe7, 0xa3, 0xb5, 0x32, 0x97, 0x94, 0xfd, 0xe1, 0x9f, 0x17,
	0x1d, 0xeb, 0xaf, 0x8b, 0x8e, 0xf5, 0xf7, 0x45, 0xc7, 0xfa, 0xfd, 0x9f, 0xce, 0x4b, 0x3f, 0x7c,
	0x51, 0xfb, 0x53, 0xb0, 0x00, 0x3d, 0xca, 0x68, 0x4e, 0x13, 0x8c, 0xbd, 0x1a, 0xec, 0x11, 0x2d,
	0x98, 0xf4, 0x0c, 0xf6, 0xd1, 0x1c, 0xdc, 0x9b, 0x76, 0xc3, 0x97, 0xf5, 0x2f, 0xcc, 0x07, 0xff,
	0x06, 0x00, 0x00, 0xff, 0xff, 0x1d, 0x90, 0x1f, 0x72, 0xd0, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BucketServiceClient is the client API for BucketService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BucketServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error)
	// BucketExists checks if the specified bucket exists
	// Required permissions:
	// - bucketservice.bucket.exists globally
	BucketExists(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.YesOrNo, error)
	// CreateBucket creates a bucket
	// Required permissions:
	// - bucketservice.bucket.create globally
	CreateBucket(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.Empty, error)
	// DeleteBucket deletes a bucket
	// Notice that this deletes all data contained in the bucket as well
	// Required permissions:
	// - bucketservice.bucket.delete globally
	DeleteBucket(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.Empty, error)
	// GetRepositoryURL get the URL needed to store/delete objects in a bucket
	// Required permissions:
	// - bucketservice.bucketpath.get-repository-url globally
	GetRepositoryURL(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*RepositoryURL, error)
	// DeletePath deletes the specified path (recursively) from the provided bucket
	// Required permissions:
	// - bucketservice.bucketpath.delete globally
	DeletePath(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*v11.Empty, error)
	// GetPathSize provides the size in bytes for the specified path from the provided bucket
	// Required permissions:
	// - bucketservice.bucketpath.get-size globally
	GetPathSize(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*PathSize, error)
	// ReadObject opens an object in the bucket and streams the existing data from the object into the client
	// Required permissions:
	// - bucketservice.bucketobject.read globally
	ReadObject(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (BucketService_ReadObjectClient, error)
	// CreateObject creates or opens an object in the bucket and allows the client to stream (additional) data into the object
	// Required permissions:
	// - bucketservice.bucketobject.write globally
	WriteObject(ctx context.Context, opts ...grpc.CallOption) (BucketService_WriteObjectClient, error)
	// GetObjectInfo provides information for the specified object from the provided bucket
	// A Not-Found error is returned if the object cannot be found
	// Required permissions:
	// - bucketservice.bucketobject.get-info globally
	GetObjectInfo(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*ObjectInfo, error)
}

type bucketServiceClient struct {
	cc *grpc.ClientConn
}

func NewBucketServiceClient(cc *grpc.ClientConn) BucketServiceClient {
	return &bucketServiceClient{cc}
}

func (c *bucketServiceClient) GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error) {
	out := new(v11.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) BucketExists(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.YesOrNo, error) {
	out := new(v11.YesOrNo)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/BucketExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) CreateBucket(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.Empty, error) {
	out := new(v11.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/CreateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) DeleteBucket(ctx context.Context, in *BucketRequest, opts ...grpc.CallOption) (*v11.Empty, error) {
	out := new(v11.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/DeleteBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) GetRepositoryURL(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*RepositoryURL, error) {
	out := new(RepositoryURL)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetRepositoryURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) DeletePath(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*v11.Empty, error) {
	out := new(v11.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/DeletePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) GetPathSize(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*PathSize, error) {
	out := new(PathSize)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetPathSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bucketServiceClient) ReadObject(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (BucketService_ReadObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BucketService_serviceDesc.Streams[0], "/arangodb.cloud.integration.bucketservice.v1.BucketService/ReadObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &bucketServiceReadObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BucketService_ReadObjectClient interface {
	Recv() (*ReadObjectChunk, error)
	grpc.ClientStream
}

type bucketServiceReadObjectClient struct {
	grpc.ClientStream
}

func (x *bucketServiceReadObjectClient) Recv() (*ReadObjectChunk, error) {
	m := new(ReadObjectChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bucketServiceClient) WriteObject(ctx context.Context, opts ...grpc.CallOption) (BucketService_WriteObjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BucketService_serviceDesc.Streams[1], "/arangodb.cloud.integration.bucketservice.v1.BucketService/WriteObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &bucketServiceWriteObjectClient{stream}
	return x, nil
}

type BucketService_WriteObjectClient interface {
	Send(*WriteObjectChunk) error
	Recv() (*WriteObjectControl, error)
	grpc.ClientStream
}

type bucketServiceWriteObjectClient struct {
	grpc.ClientStream
}

func (x *bucketServiceWriteObjectClient) Send(m *WriteObjectChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bucketServiceWriteObjectClient) Recv() (*WriteObjectControl, error) {
	m := new(WriteObjectControl)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bucketServiceClient) GetObjectInfo(ctx context.Context, in *PathRequest, opts ...grpc.CallOption) (*ObjectInfo, error) {
	out := new(ObjectInfo)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetObjectInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BucketServiceServer is the server API for BucketService service.
type BucketServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v11.Empty) (*v11.Version, error)
	// BucketExists checks if the specified bucket exists
	// Required permissions:
	// - bucketservice.bucket.exists globally
	BucketExists(context.Context, *BucketRequest) (*v11.YesOrNo, error)
	// CreateBucket creates a bucket
	// Required permissions:
	// - bucketservice.bucket.create globally
	CreateBucket(context.Context, *BucketRequest) (*v11.Empty, error)
	// DeleteBucket deletes a bucket
	// Notice that this deletes all data contained in the bucket as well
	// Required permissions:
	// - bucketservice.bucket.delete globally
	DeleteBucket(context.Context, *BucketRequest) (*v11.Empty, error)
	// GetRepositoryURL get the URL needed to store/delete objects in a bucket
	// Required permissions:
	// - bucketservice.bucketpath.get-repository-url globally
	GetRepositoryURL(context.Context, *PathRequest) (*RepositoryURL, error)
	// DeletePath deletes the specified path (recursively) from the provided bucket
	// Required permissions:
	// - bucketservice.bucketpath.delete globally
	DeletePath(context.Context, *PathRequest) (*v11.Empty, error)
	// GetPathSize provides the size in bytes for the specified path from the provided bucket
	// Required permissions:
	// - bucketservice.bucketpath.get-size globally
	GetPathSize(context.Context, *PathRequest) (*PathSize, error)
	// ReadObject opens an object in the bucket and streams the existing data from the object into the client
	// Required permissions:
	// - bucketservice.bucketobject.read globally
	ReadObject(*PathRequest, BucketService_ReadObjectServer) error
	// CreateObject creates or opens an object in the bucket and allows the client to stream (additional) data into the object
	// Required permissions:
	// - bucketservice.bucketobject.write globally
	WriteObject(BucketService_WriteObjectServer) error
	// GetObjectInfo provides information for the specified object from the provided bucket
	// A Not-Found error is returned if the object cannot be found
	// Required permissions:
	// - bucketservice.bucketobject.get-info globally
	GetObjectInfo(context.Context, *PathRequest) (*ObjectInfo, error)
}

// UnimplementedBucketServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBucketServiceServer struct {
}

func (*UnimplementedBucketServiceServer) GetAPIVersion(ctx context.Context, req *v11.Empty) (*v11.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedBucketServiceServer) BucketExists(ctx context.Context, req *BucketRequest) (*v11.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BucketExists not implemented")
}
func (*UnimplementedBucketServiceServer) CreateBucket(ctx context.Context, req *BucketRequest) (*v11.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBucket not implemented")
}
func (*UnimplementedBucketServiceServer) DeleteBucket(ctx context.Context, req *BucketRequest) (*v11.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucket not implemented")
}
func (*UnimplementedBucketServiceServer) GetRepositoryURL(ctx context.Context, req *PathRequest) (*RepositoryURL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRepositoryURL not implemented")
}
func (*UnimplementedBucketServiceServer) DeletePath(ctx context.Context, req *PathRequest) (*v11.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePath not implemented")
}
func (*UnimplementedBucketServiceServer) GetPathSize(ctx context.Context, req *PathRequest) (*PathSize, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPathSize not implemented")
}
func (*UnimplementedBucketServiceServer) ReadObject(req *PathRequest, srv BucketService_ReadObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadObject not implemented")
}
func (*UnimplementedBucketServiceServer) WriteObject(srv BucketService_WriteObjectServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteObject not implemented")
}
func (*UnimplementedBucketServiceServer) GetObjectInfo(ctx context.Context, req *PathRequest) (*ObjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObjectInfo not implemented")
}

func RegisterBucketServiceServer(s *grpc.Server, srv BucketServiceServer) {
	s.RegisterService(&_BucketService_serviceDesc, srv)
}

func _BucketService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetAPIVersion(ctx, req.(*v11.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_BucketExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).BucketExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/BucketExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).BucketExists(ctx, req.(*BucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/CreateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).CreateBucket(ctx, req.(*BucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/DeleteBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).DeleteBucket(ctx, req.(*BucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_GetRepositoryURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetRepositoryURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetRepositoryURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetRepositoryURL(ctx, req.(*PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_DeletePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).DeletePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/DeletePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).DeletePath(ctx, req.(*PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_GetPathSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetPathSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetPathSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetPathSize(ctx, req.(*PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BucketService_ReadObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PathRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BucketServiceServer).ReadObject(m, &bucketServiceReadObjectServer{stream})
}

type BucketService_ReadObjectServer interface {
	Send(*ReadObjectChunk) error
	grpc.ServerStream
}

type bucketServiceReadObjectServer struct {
	grpc.ServerStream
}

func (x *bucketServiceReadObjectServer) Send(m *ReadObjectChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _BucketService_WriteObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BucketServiceServer).WriteObject(&bucketServiceWriteObjectServer{stream})
}

type BucketService_WriteObjectServer interface {
	Send(*WriteObjectControl) error
	Recv() (*WriteObjectChunk, error)
	grpc.ServerStream
}

type bucketServiceWriteObjectServer struct {
	grpc.ServerStream
}

func (x *bucketServiceWriteObjectServer) Send(m *WriteObjectControl) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bucketServiceWriteObjectServer) Recv() (*WriteObjectChunk, error) {
	m := new(WriteObjectChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BucketService_GetObjectInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BucketServiceServer).GetObjectInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.integration.bucketservice.v1.BucketService/GetObjectInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BucketServiceServer).GetObjectInfo(ctx, req.(*PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BucketService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.integration.bucketservice.v1.BucketService",
	HandlerType: (*BucketServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _BucketService_GetAPIVersion_Handler,
		},
		{
			MethodName: "BucketExists",
			Handler:    _BucketService_BucketExists_Handler,
		},
		{
			MethodName: "CreateBucket",
			Handler:    _BucketService_CreateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _BucketService_DeleteBucket_Handler,
		},
		{
			MethodName: "GetRepositoryURL",
			Handler:    _BucketService_GetRepositoryURL_Handler,
		},
		{
			MethodName: "DeletePath",
			Handler:    _BucketService_DeletePath_Handler,
		},
		{
			MethodName: "GetPathSize",
			Handler:    _BucketService_GetPathSize_Handler,
		},
		{
			MethodName: "GetObjectInfo",
			Handler:    _BucketService_GetObjectInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadObject",
			Handler:       _BucketService_ReadObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteObject",
			Handler:       _BucketService_WriteObject_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "bucketservice.proto",
}

func (m *BucketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBucketservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBucketservice(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *RepositoryURL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepositoryURL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepositoryURL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BucketPath) > 0 {
		i -= len(m.BucketPath)
		copy(dAtA[i:], m.BucketPath)
		i = encodeVarintBucketservice(dAtA, i, uint64(len(m.BucketPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintBucketservice(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumberOfFolders != 0 {
		i = encodeVarintBucketservice(dAtA, i, uint64(m.NumberOfFolders))
		i--
		dAtA[i] = 0x18
	}
	if m.NumberOfFiles != 0 {
		i = encodeVarintBucketservice(dAtA, i, uint64(m.NumberOfFiles))
		i--
		dAtA[i] = 0x10
	}
	if m.SizeInBytes != 0 {
		i = encodeVarintBucketservice(dAtA, i, uint64(m.SizeInBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBucketservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SizeInBytes != 0 {
		i = encodeVarintBucketservice(dAtA, i, uint64(m.SizeInBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadObjectChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadObjectChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadObjectChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Chunk) > 0 {
		i -= len(m.Chunk)
		copy(dAtA[i:], m.Chunk)
		i = encodeVarintBucketservice(dAtA, i, uint64(len(m.Chunk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteObjectChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteObjectChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteObjectChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Chunk) > 0 {
		i -= len(m.Chunk)
		copy(dAtA[i:], m.Chunk)
		i = encodeVarintBucketservice(dAtA, i, uint64(len(m.Chunk)))
		i--
		dAtA[i] = 0x12
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBucketservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteObjectControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteObjectControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteObjectControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxChunkBytes != 0 {
		i = encodeVarintBucketservice(dAtA, i, uint64(m.MaxChunkBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.AllowMoreOutput {
		i--
		if m.AllowMoreOutput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBucketservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovBucketservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BucketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovBucketservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBucketservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepositoryURL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovBucketservice(uint64(l))
	}
	l = len(m.BucketPath)
	if l > 0 {
		n += 1 + l + sovBucketservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SizeInBytes != 0 {
		n += 1 + sovBucketservice(uint64(m.SizeInBytes))
	}
	if m.NumberOfFiles != 0 {
		n += 1 + sovBucketservice(uint64(m.NumberOfFiles))
	}
	if m.NumberOfFolders != 0 {
		n += 1 + sovBucketservice(uint64(m.NumberOfFolders))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLocked {
		n += 2
	}
	if m.SizeInBytes != 0 {
		n += 1 + sovBucketservice(uint64(m.SizeInBytes))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovBucketservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadObjectChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chunk)
	if l > 0 {
		n += 1 + l + sovBucketservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteObjectChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovBucketservice(uint64(l))
	}
	l = len(m.Chunk)
	if l > 0 {
		n += 1 + l + sovBucketservice(uint64(l))
	}
	if m.HasMore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteObjectControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowMoreOutput {
		n += 2
	}
	if m.MaxChunkBytes != 0 {
		n += 1 + sovBucketservice(uint64(m.MaxChunkBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBucketservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBucketservice(x uint64) (n int) {
	return sovBucketservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BucketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &v1.KeyValuePair{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepositoryURL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepositoryURL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepositoryURL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BucketPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeInBytes", wireType)
			}
			m.SizeInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeInBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFiles", wireType)
			}
			m.NumberOfFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFiles |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFolders", wireType)
			}
			m.NumberOfFolders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFolders |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeInBytes", wireType)
			}
			m.SizeInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeInBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadObjectChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadObjectChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadObjectChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunk = append(m.Chunk[:0], dAtA[iNdEx:postIndex]...)
			if m.Chunk == nil {
				m.Chunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteObjectChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteObjectChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteObjectChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &PathRequest{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBucketservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBucketservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunk = append(m.Chunk[:0], dAtA[iNdEx:postIndex]...)
			if m.Chunk == nil {
				m.Chunk = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteObjectControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteObjectControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteObjectControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMoreOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMoreOutput = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChunkBytes", wireType)
			}
			m.MaxChunkBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChunkBytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBucketservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBucketservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBucketservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBucketservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBucketservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBucketservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBucketservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBucketservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBucketservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBucketservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBucketservice = fmt.Errorf("proto: unexpected end of group")
)
