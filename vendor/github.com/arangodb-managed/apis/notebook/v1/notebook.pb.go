// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: notebook.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	v11 "github.com/arangodb-managed/apis/data/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// List of Notebooks.
type NotebookList struct {
	Items []*Notebook `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Budget for notebooks
	Budget               *v1.Budget `protobuf:"bytes,2,opt,name=budget,proto3" json:"budget,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NotebookList) Reset()         { *m = NotebookList{} }
func (m *NotebookList) String() string { return proto.CompactTextString(m) }
func (*NotebookList) ProtoMessage()    {}
func (*NotebookList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{0}
}
func (m *NotebookList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookList.Merge(m, src)
}
func (m *NotebookList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookList proto.InternalMessageInfo

func (m *NotebookList) GetItems() []*Notebook {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *NotebookList) GetBudget() *v1.Budget {
	if m != nil {
		return m.Budget
	}
	return nil
}

// Request for listing notebooks.
type ListNotebooksRequest struct {
	// List notebooks for this deployment ID.
	// This is a required field.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Optional common list options, the context_id is ignored
	Options              *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ListNotebooksRequest) Reset()         { *m = ListNotebooksRequest{} }
func (m *ListNotebooksRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebooksRequest) ProtoMessage()    {}
func (*ListNotebooksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{1}
}
func (m *ListNotebooksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebooksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebooksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebooksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebooksRequest.Merge(m, src)
}
func (m *ListNotebooksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebooksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebooksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebooksRequest proto.InternalMessageInfo

func (m *ListNotebooksRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *ListNotebooksRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Contains the specification and status of a given notebook instance.
type Notebook struct {
	// ID of the Notebook.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ID of the Deployment this notebook belongs to.
	// After creation, this value cannot be changed.
	// This is a required field.
	DeploymentId string `protobuf:"bytes,2,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// URL of the Notebook.
	// This is a read-only value.
	Url string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the notebook.
	// This is a required field.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the notebook.
	// This is an optional field.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Indicates that this notebook is paused.
	// Use the notebook.PauseNotebook method to pause, and notebook.ResumeNotebook to resume (unpause).
	// This is a read-only value.
	IsPaused bool `protobuf:"varint,6,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// The last paused timestamp of the notebook.
	// This is the timestamp that is_paused is transitioned from unset to set.
	// This is a read-only value.
	LastPausedAt *types.Timestamp `protobuf:"bytes,7,opt,name=last_paused_at,json=lastPausedAt,proto3" json:"last_paused_at,omitempty"`
	// The last resumed timestamp of the notebook.
	// This is the timestamp that is_paused is transitioned from set to unset.
	// This is a read-only value.
	LastResumedAt *types.Timestamp `protobuf:"bytes,8,opt,name=last_resumed_at,json=lastResumedAt,proto3" json:"last_resumed_at,omitempty"`
	// Identifier of the user that created this notebook.
	// This is a read-only value.
	CreatedById string `protobuf:"bytes,9,opt,name=created_by_id,json=createdById,proto3" json:"created_by_id,omitempty"`
	// Time at which this notebook was created.
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Model specification for the notebook.
	Model *ModelSpec `protobuf:"bytes,11,opt,name=model,proto3" json:"model,omitempty"`
	// Set when this notebook is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,12,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// The deletion timestamp of the deployment
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,13,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Status of the notebook.
	// This is a read-only value.
	Status               *Status  `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notebook) Reset()         { *m = Notebook{} }
func (m *Notebook) String() string { return proto.CompactTextString(m) }
func (*Notebook) ProtoMessage()    {}
func (*Notebook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{2}
}
func (m *Notebook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notebook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notebook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notebook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notebook.Merge(m, src)
}
func (m *Notebook) XXX_Size() int {
	return m.Size()
}
func (m *Notebook) XXX_DiscardUnknown() {
	xxx_messageInfo_Notebook.DiscardUnknown(m)
}

var xxx_messageInfo_Notebook proto.InternalMessageInfo

func (m *Notebook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Notebook) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *Notebook) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Notebook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Notebook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Notebook) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

func (m *Notebook) GetLastPausedAt() *types.Timestamp {
	if m != nil {
		return m.LastPausedAt
	}
	return nil
}

func (m *Notebook) GetLastResumedAt() *types.Timestamp {
	if m != nil {
		return m.LastResumedAt
	}
	return nil
}

func (m *Notebook) GetCreatedById() string {
	if m != nil {
		return m.CreatedById
	}
	return ""
}

func (m *Notebook) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Notebook) GetModel() *ModelSpec {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *Notebook) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *Notebook) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Notebook) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Model specification for the notebook.
type ModelSpec struct {
	// Type of model being used.
	// This should refer to the `id` of a `NotebookModel` object.
	// This is a required field.
	NotebookModelId string `protobuf:"bytes,1,opt,name=notebook_model_id,json=notebookModelId,proto3" json:"notebook_model_id,omitempty"`
	// Disk size allocated to the notebook instance (in GiB).
	// This is a required field.
	DiskSize             int32    `protobuf:"varint,2,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelSpec) Reset()         { *m = ModelSpec{} }
func (m *ModelSpec) String() string { return proto.CompactTextString(m) }
func (*ModelSpec) ProtoMessage()    {}
func (*ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{3}
}
func (m *ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelSpec.Merge(m, src)
}
func (m *ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ModelSpec proto.InternalMessageInfo

func (m *ModelSpec) GetNotebookModelId() string {
	if m != nil {
		return m.NotebookModelId
	}
	return ""
}

func (m *ModelSpec) GetDiskSize() int32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Specifies the resource configuration for a notebook.
type NotebookModel struct {
	// System identifier of the model.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable name of the model.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// CPU units allocated to the notebook.
	// 1 CPU unit equals 1 physical / virtual CPU.
	Cpu float32 `protobuf:"fixed32,3,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// Memory allocated to the notebook in 'GiB'.
	Memory int32 `protobuf:"varint,4,opt,name=memory,proto3" json:"memory,omitempty"`
	// Maximum amount of disk space (in GiB) available to the notebook.
	MaxDiskSize int32 `protobuf:"varint,5,opt,name=max_disk_size,json=maxDiskSize,proto3" json:"max_disk_size,omitempty"`
	// Minimum amount of disk space (in GiB) available to the notebook.
	MinDiskSize          int32    `protobuf:"varint,6,opt,name=min_disk_size,json=minDiskSize,proto3" json:"min_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotebookModel) Reset()         { *m = NotebookModel{} }
func (m *NotebookModel) String() string { return proto.CompactTextString(m) }
func (*NotebookModel) ProtoMessage()    {}
func (*NotebookModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{4}
}
func (m *NotebookModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookModel.Merge(m, src)
}
func (m *NotebookModel) XXX_Size() int {
	return m.Size()
}
func (m *NotebookModel) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookModel.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookModel proto.InternalMessageInfo

func (m *NotebookModel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NotebookModel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NotebookModel) GetCpu() float32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *NotebookModel) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *NotebookModel) GetMaxDiskSize() int32 {
	if m != nil {
		return m.MaxDiskSize
	}
	return 0
}

func (m *NotebookModel) GetMinDiskSize() int32 {
	if m != nil {
		return m.MinDiskSize
	}
	return 0
}

// List of notebook models.
type NotebookModelList struct {
	Items                []*NotebookModel `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *NotebookModelList) Reset()         { *m = NotebookModelList{} }
func (m *NotebookModelList) String() string { return proto.CompactTextString(m) }
func (*NotebookModelList) ProtoMessage()    {}
func (*NotebookModelList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{5}
}
func (m *NotebookModelList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotebookModelList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotebookModelList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotebookModelList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotebookModelList.Merge(m, src)
}
func (m *NotebookModelList) XXX_Size() int {
	return m.Size()
}
func (m *NotebookModelList) XXX_DiscardUnknown() {
	xxx_messageInfo_NotebookModelList.DiscardUnknown(m)
}

var xxx_messageInfo_NotebookModelList proto.InternalMessageInfo

func (m *NotebookModelList) GetItems() []*NotebookModel {
	if m != nil {
		return m.Items
	}
	return nil
}

// Requet for listing notebook models.
type ListNotebookModelsRequest struct {
	// ID of the deployment that the notebook belongs to.
	DeploymentId         string   `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListNotebookModelsRequest) Reset()         { *m = ListNotebookModelsRequest{} }
func (m *ListNotebookModelsRequest) String() string { return proto.CompactTextString(m) }
func (*ListNotebookModelsRequest) ProtoMessage()    {}
func (*ListNotebookModelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{6}
}
func (m *ListNotebookModelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNotebookModelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNotebookModelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNotebookModelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNotebookModelsRequest.Merge(m, src)
}
func (m *ListNotebookModelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListNotebookModelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNotebookModelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListNotebookModelsRequest proto.InternalMessageInfo

func (m *ListNotebookModelsRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

// Status of the notebook.
// Note: all fields in this block are read-only.
type Status struct {
	// Where the notebook is in its lifecycle at any given time.
	// Should contain only one of the following values:
	// "Initialising"   - Notebook is initialising.
	// "Running"        - Notebook is running.
	// "Hibernating"    - Notebook is moving to a hibernated state.
	// "Hibernated"     - Notebook has moved to a hibernated state.
	// "Error"          - Notebook is in an errored state. Additional information can be obtained from `message` field.
	Phase string `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	// Supporting information about the notebook phase - such as error messages in case of failures.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// The timestamp of when the status of the notebook was last updated.
	LastUpdatedAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Endpoint URL used to reach the notebook
	// This value will be empty during the creation of the notebook.
	Endpoint string `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Resource usage of the notebook.
	Usage                *Status_Usage `protobuf:"bytes,10,opt,name=usage,proto3" json:"usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{7}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

func (m *Status) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Status) GetUsage() *Status_Usage {
	if m != nil {
		return m.Usage
	}
	return nil
}

// Resource usage of the notebook.
type Status_Usage struct {
	// Information about the data volume used to store the data
	DataVolumeInfo *v11.DataVolumeInfo `protobuf:"bytes,1,opt,name=data_volume_info,json=dataVolumeInfo,proto3" json:"data_volume_info,omitempty"`
	// Last known memory usage in bytes
	LastMemoryUsage int64 `protobuf:"varint,2,opt,name=last_memory_usage,json=lastMemoryUsage,proto3" json:"last_memory_usage,omitempty"`
	// Last known CPU usage in vCPU units
	LastCpuUsage float32 `protobuf:"fixed32,3,opt,name=last_cpu_usage,json=lastCpuUsage,proto3" json:"last_cpu_usage,omitempty"`
	// Last known memory limit in bytes
	LastMemoryLimit int64 `protobuf:"varint,4,opt,name=last_memory_limit,json=lastMemoryLimit,proto3" json:"last_memory_limit,omitempty"`
	// Last known CPU limit in vCPU units
	LastCpuLimit         float32  `protobuf:"fixed32,5,opt,name=last_cpu_limit,json=lastCpuLimit,proto3" json:"last_cpu_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status_Usage) Reset()         { *m = Status_Usage{} }
func (m *Status_Usage) String() string { return proto.CompactTextString(m) }
func (*Status_Usage) ProtoMessage()    {}
func (*Status_Usage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e4288154b4c2ba34, []int{7, 0}
}
func (m *Status_Usage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status_Usage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status_Usage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status_Usage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status_Usage.Merge(m, src)
}
func (m *Status_Usage) XXX_Size() int {
	return m.Size()
}
func (m *Status_Usage) XXX_DiscardUnknown() {
	xxx_messageInfo_Status_Usage.DiscardUnknown(m)
}

var xxx_messageInfo_Status_Usage proto.InternalMessageInfo

func (m *Status_Usage) GetDataVolumeInfo() *v11.DataVolumeInfo {
	if m != nil {
		return m.DataVolumeInfo
	}
	return nil
}

func (m *Status_Usage) GetLastMemoryUsage() int64 {
	if m != nil {
		return m.LastMemoryUsage
	}
	return 0
}

func (m *Status_Usage) GetLastCpuUsage() float32 {
	if m != nil {
		return m.LastCpuUsage
	}
	return 0
}

func (m *Status_Usage) GetLastMemoryLimit() int64 {
	if m != nil {
		return m.LastMemoryLimit
	}
	return 0
}

func (m *Status_Usage) GetLastCpuLimit() float32 {
	if m != nil {
		return m.LastCpuLimit
	}
	return 0
}

func init() {
	proto.RegisterType((*NotebookList)(nil), "arangodb.cloud.notebook.v1.NotebookList")
	proto.RegisterType((*ListNotebooksRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebooksRequest")
	proto.RegisterType((*Notebook)(nil), "arangodb.cloud.notebook.v1.Notebook")
	proto.RegisterType((*ModelSpec)(nil), "arangodb.cloud.notebook.v1.ModelSpec")
	proto.RegisterType((*NotebookModel)(nil), "arangodb.cloud.notebook.v1.NotebookModel")
	proto.RegisterType((*NotebookModelList)(nil), "arangodb.cloud.notebook.v1.NotebookModelList")
	proto.RegisterType((*ListNotebookModelsRequest)(nil), "arangodb.cloud.notebook.v1.ListNotebookModelsRequest")
	proto.RegisterType((*Status)(nil), "arangodb.cloud.notebook.v1.Status")
	proto.RegisterType((*Status_Usage)(nil), "arangodb.cloud.notebook.v1.Status.Usage")
}

func init() { proto.RegisterFile("notebook.proto", fileDescriptor_e4288154b4c2ba34) }

var fileDescriptor_e4288154b4c2ba34 = []byte{
	// 1158 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x41, 0x6f, 0x13, 0x47,
	0x14, 0xee, 0xda, 0xd8, 0xd8, 0xe3, 0xd8, 0xc0, 0x08, 0xd1, 0x65, 0x09, 0xc6, 0xdd, 0x00, 0x32,
	0xa8, 0xac, 0x9b, 0x54, 0x95, 0x5a, 0x90, 0x00, 0x87, 0x54, 0xc8, 0x12, 0xd0, 0x68, 0x13, 0x38,
	0xf4, 0x62, 0x8d, 0xbd, 0x13, 0x33, 0xc2, 0xbb, 0xb3, 0xf5, 0xcc, 0x5a, 0x38, 0xa5, 0x55, 0x85,
	0xfa, 0x0b, 0xda, 0x4b, 0x4f, 0xbd, 0xf5, 0xbf, 0xb4, 0xb7, 0x4a, 0xbd, 0xf4, 0xd0, 0x43, 0x95,
	0xf6, 0x6f, 0x54, 0xaa, 0xe6, 0xcd, 0xac, 0x63, 0xc7, 0x71, 0xec, 0x48, 0x9c, 0xbc, 0xf3, 0xe6,
	0x7b, 0xef, 0x7d, 0xf3, 0xe6, 0x9b, 0x37, 0x63, 0x54, 0x89, 0xb8, 0xa4, 0x1d, 0xce, 0x5f, 0x79,
	0xf1, 0x80, 0x4b, 0x8e, 0x1d, 0x32, 0x20, 0x51, 0x8f, 0x07, 0x1d, 0xaf, 0xdb, 0xe7, 0x49, 0xe0,
	0x8d, 0xa7, 0x87, 0xeb, 0xce, 0xa5, 0x2e, 0x0f, 0x43, 0x1e, 0x35, 0x86, 0xeb, 0x0d, 0xfd, 0xa5,
	0x7d, 0x1c, 0x1c, 0x10, 0x49, 0x94, 0x55, 0xfd, 0x1a, 0xdb, 0xbd, 0x1e, 0x93, 0x2f, 0x93, 0x8e,
	0xd7, 0xe5, 0x61, 0xa3, 0xc7, 0xfb, 0x24, 0xea, 0x35, 0x60, 0xa2, 0x93, 0xec, 0x35, 0x62, 0x39,
	0x8a, 0xa9, 0x68, 0x48, 0x16, 0x52, 0x21, 0x49, 0x18, 0x1f, 0x7e, 0x19, 0xe7, 0xd5, 0x1e, 0xe7,
	0xbd, 0x3e, 0x6d, 0x90, 0x98, 0x35, 0x48, 0x14, 0x71, 0x49, 0x24, 0xe3, 0x91, 0xd0, 0xb3, 0xee,
	0xf7, 0x16, 0x5a, 0x79, 0x66, 0x68, 0x3d, 0x61, 0x42, 0xe2, 0xbb, 0x28, 0xc7, 0x24, 0x0d, 0x85,
	0x6d, 0xd5, 0xb2, 0xf5, 0xd2, 0xc6, 0x75, 0x6f, 0xfe, 0x1a, 0xbc, 0xd4, 0xd1, 0xd7, 0x2e, 0xf8,
	0x53, 0x94, 0xef, 0x24, 0x41, 0x8f, 0x4a, 0x3b, 0x53, 0xb3, 0xea, 0xa5, 0x8d, 0xda, 0x51, 0x67,
	0xb3, 0xd2, 0xe1, 0xba, 0xb7, 0x09, 0x38, 0xdf, 0xe0, 0xdd, 0x37, 0xe8, 0xa2, 0xca, 0x9e, 0x06,
	0x14, 0x3e, 0xfd, 0x2a, 0xa1, 0x42, 0xe2, 0x35, 0x54, 0x0e, 0x68, 0xdc, 0xe7, 0xa3, 0x90, 0x46,
	0xb2, 0xcd, 0x02, 0xdb, 0xaa, 0x59, 0xf5, 0xa2, 0xbf, 0x72, 0x68, 0x6c, 0x05, 0xf8, 0x01, 0x3a,
	0xcb, 0x63, 0x58, 0x94, 0x8d, 0x20, 0xef, 0x8d, 0xf9, 0x79, 0x55, 0x96, 0x2f, 0x34, 0xd8, 0x4f,
	0xbd, 0xdc, 0xbf, 0xce, 0xa0, 0x42, 0x9a, 0x1a, 0x57, 0x50, 0x66, 0x9c, 0x27, 0xc3, 0x82, 0x59,
	0x0a, 0x99, 0x63, 0x28, 0x9c, 0x47, 0xd9, 0x64, 0xd0, 0xb7, 0xb3, 0x30, 0xa5, 0x3e, 0x31, 0x46,
	0x67, 0x22, 0x12, 0x52, 0xfb, 0x0c, 0x98, 0xe0, 0x1b, 0xd7, 0x50, 0x29, 0xa0, 0xa2, 0x3b, 0x60,
	0x90, 0xd7, 0xce, 0xc1, 0xd4, 0xa4, 0x09, 0x5f, 0x41, 0x45, 0x26, 0xda, 0x31, 0x49, 0x04, 0x0d,
	0xec, 0x7c, 0xcd, 0xaa, 0x17, 0xfc, 0x02, 0x13, 0xdb, 0x30, 0xc6, 0x0f, 0x51, 0xa5, 0x4f, 0x84,
	0x34, 0xd3, 0x6d, 0x22, 0xed, 0xb3, 0xb0, 0x5c, 0xc7, 0xd3, 0x5b, 0xec, 0xa5, 0xa2, 0xf0, 0x76,
	0x53, 0x0d, 0xf8, 0x2b, 0xca, 0x43, 0xfb, 0x37, 0x25, 0xde, 0x44, 0xe7, 0x20, 0xc2, 0x80, 0x8a,
	0x24, 0xd4, 0x21, 0x0a, 0x0b, 0x43, 0x94, 0x95, 0x8b, 0xaf, 0x3d, 0x9a, 0x12, 0xbb, 0xa8, 0xdc,
	0x1d, 0x50, 0x22, 0x69, 0xd0, 0xee, 0x8c, 0x54, 0x3d, 0x8a, 0x7a, 0x19, 0xc6, 0xb8, 0x39, 0x6a,
	0x05, 0xf8, 0x33, 0x84, 0x52, 0x0c, 0x91, 0x66, 0x53, 0x4e, 0x4a, 0x51, 0x34, 0xe8, 0xa6, 0xc4,
	0xf7, 0x50, 0x2e, 0xe4, 0x01, 0xed, 0xdb, 0xa5, 0xe3, 0xb7, 0x72, 0x52, 0x7f, 0x4f, 0x15, 0x70,
	0x27, 0xa6, 0x5d, 0x5f, 0xfb, 0xe0, 0xab, 0x08, 0x31, 0xd1, 0x0e, 0x68, 0x9f, 0x4a, 0x1a, 0xd8,
	0x2b, 0x50, 0xbf, 0x22, 0x13, 0x5b, 0xda, 0xa0, 0x68, 0x99, 0x39, 0x45, 0xab, 0xbc, 0x98, 0x96,
	0x41, 0x37, 0xd5, 0xb1, 0xc8, 0x0b, 0x49, 0x64, 0x22, 0xec, 0x00, 0xdc, 0xdc, 0x93, 0x78, 0xed,
	0x00, 0xd2, 0x37, 0x1e, 0xee, 0x2e, 0x2a, 0x8e, 0x99, 0xe2, 0xdb, 0xe8, 0x42, 0x0a, 0x6d, 0x03,
	0xe9, 0x43, 0x55, 0x9f, 0x4b, 0x27, 0x00, 0xdd, 0x0a, 0x94, 0x1a, 0x02, 0x26, 0x5e, 0xb5, 0x05,
	0xdb, 0xa7, 0x20, 0xbb, 0x9c, 0x5f, 0x50, 0x86, 0x1d, 0xb6, 0x4f, 0xdd, 0x5f, 0x2c, 0x54, 0x7e,
	0x36, 0xe9, 0x30, 0xa3, 0xdc, 0x54, 0x82, 0x99, 0x09, 0x09, 0x9e, 0x47, 0xd9, 0x6e, 0x9c, 0x80,
	0x50, 0x33, 0xbe, 0xfa, 0xc4, 0x97, 0x50, 0x3e, 0xa4, 0x21, 0x1f, 0x8c, 0x40, 0xaa, 0x39, 0xdf,
	0x8c, 0xd4, 0x3e, 0x87, 0xe4, 0x75, 0xfb, 0x90, 0x40, 0x0e, 0xa6, 0x4b, 0x21, 0x79, 0xbd, 0x65,
	0x38, 0x00, 0x86, 0x45, 0x13, 0x98, 0xbc, 0xc1, 0xb0, 0x28, 0xc5, 0xb8, 0xbb, 0xe8, 0xc2, 0x14,
	0x4d, 0xe8, 0x32, 0x0f, 0xa6, 0xbb, 0xcc, 0xad, 0x65, 0xba, 0x0c, 0x78, 0x9b, 0x56, 0xe3, 0x3e,
	0x44, 0x97, 0x27, 0x1b, 0x06, 0xcc, 0x9d, 0xaa, 0x6b, 0xb8, 0x7f, 0x66, 0x51, 0x5e, 0x6f, 0x14,
	0xbe, 0x88, 0x72, 0xf1, 0x4b, 0x22, 0xa8, 0xc1, 0xe9, 0x01, 0xb6, 0xd1, 0xd9, 0x90, 0x0a, 0x41,
	0x7a, 0x69, 0x05, 0xd3, 0xe1, 0xf8, 0x18, 0x25, 0x71, 0x90, 0x6a, 0x3c, 0xbb, 0xdc, 0x31, 0x7a,
	0xae, 0x3d, 0x9a, 0x12, 0x3b, 0xa8, 0x40, 0xa3, 0x20, 0xe6, 0x2c, 0x92, 0xa6, 0x47, 0x8c, 0xc7,
	0xf8, 0x3e, 0xca, 0x25, 0x90, 0x57, 0x9f, 0x9c, 0xfa, 0x62, 0xad, 0x79, 0xcf, 0x15, 0xde, 0xd7,
	0x6e, 0xce, 0x7f, 0x16, 0xca, 0x81, 0x01, 0x6f, 0xa3, 0xf3, 0xea, 0x1e, 0x69, 0x0f, 0x79, 0x3f,
	0x09, 0x69, 0x9b, 0x45, 0x7b, 0x1c, 0x16, 0x59, 0xda, 0xb8, 0x79, 0x34, 0x28, 0xdc, 0x37, 0xc3,
	0x75, 0x6f, 0x8b, 0x48, 0xf2, 0x02, 0xe0, 0xad, 0x68, 0x8f, 0xfb, 0x95, 0x60, 0x6a, 0xac, 0xf4,
	0x0b, 0x6b, 0xd7, 0x2a, 0x69, 0x27, 0xe3, 0xfa, 0x64, 0x7d, 0x28, 0xca, 0x53, 0xb0, 0xeb, 0xec,
	0xd7, 0x4d, 0xc3, 0xea, 0xc6, 0x89, 0x01, 0x6a, 0xdd, 0x41, 0x53, 0x7a, 0x14, 0x27, 0x1a, 0x75,
	0x24, 0x62, 0x9f, 0x85, 0x4c, 0x97, 0x64, 0x2a, 0xe2, 0x13, 0x65, 0x9e, 0x8a, 0xa8, 0x81, 0xb9,
	0xa9, 0x88, 0x80, 0xda, 0xf8, 0xad, 0x88, 0xce, 0xa5, 0xca, 0xd8, 0xa1, 0x83, 0x21, 0xeb, 0x52,
	0x3c, 0x42, 0xe5, 0xc7, 0x54, 0x36, 0xb7, 0x5b, 0x2f, 0xe8, 0x40, 0xa8, 0x56, 0x7b, 0x6d, 0xfe,
	0x25, 0xf1, 0x79, 0x18, 0xcb, 0x91, 0xf3, 0xc1, 0x7c, 0x80, 0x89, 0xe1, 0x5e, 0x7f, 0xfb, 0xc7,
	0xbf, 0x3f, 0x66, 0xaa, 0x78, 0x15, 0x6e, 0xd7, 0x74, 0x5b, 0xd4, 0xed, 0x4d, 0x62, 0x76, 0x67,
	0x68, 0x32, 0x7d, 0x67, 0xa1, 0xd2, 0x63, 0x3a, 0xd6, 0x2a, 0x5e, 0x9b, 0x1f, 0xb8, 0xb5, 0x65,
	0x2e, 0x27, 0x67, 0xa9, 0x8b, 0xd7, 0xbd, 0x09, 0x04, 0x6a, 0xb8, 0x3a, 0x43, 0x60, 0xfc, 0xfd,
	0x35, 0x0b, 0xbe, 0xc1, 0x6f, 0x2d, 0x54, 0x79, 0x04, 0x3d, 0x76, 0xcc, 0x62, 0xa9, 0x04, 0x4b,
	0xd2, 0x30, 0x75, 0x70, 0x2e, 0xcf, 0xa5, 0x71, 0xd7, 0xba, 0x8d, 0xbf, 0x45, 0x15, 0xdd, 0x89,
	0x4f, 0x57, 0x89, 0x45, 0x1b, 0x95, 0x16, 0xe1, 0xf6, 0x32, 0x45, 0xd0, 0x07, 0xf0, 0x94, 0x45,
	0x58, 0xc8, 0xe0, 0x16, 0x30, 0x58, 0x73, 0x17, 0x30, 0x50, 0x45, 0xf8, 0xc1, 0x42, 0xe5, 0xa9,
	0xa7, 0x0e, 0xfe, 0xe8, 0x24, 0x0e, 0xc7, 0xbd, 0x8a, 0x9c, 0xfa, 0x32, 0xac, 0x95, 0xa7, 0x7b,
	0x03, 0x88, 0x5d, 0x73, 0x9d, 0xb9, 0xc4, 0x84, 0x22, 0xf5, 0xb3, 0x85, 0xf0, 0x6c, 0x3b, 0xc5,
	0x9f, 0x2c, 0xcb, 0x6c, 0xaa, 0xfd, 0x3a, 0x77, 0x96, 0xee, 0xe6, 0xc0, 0xd1, 0x05, 0x8e, 0xab,
	0xee, 0xfb, 0x33, 0x1c, 0xe1, 0x7e, 0x04, 0x82, 0xfb, 0xa8, 0x0c, 0x8f, 0x98, 0x77, 0xac, 0x9c,
	0x35, 0x48, 0x7d, 0xd5, 0xbd, 0x32, 0x93, 0x5a, 0x6d, 0x57, 0x03, 0x1e, 0x5a, 0xf8, 0x0d, 0xaa,
	0xe8, 0xd7, 0xcf, 0x3b, 0x4e, 0x6e, 0x0e, 0x8d, 0xbb, 0x7a, 0x7c, 0x72, 0xfd, 0x46, 0xdb, 0xbc,
	0xff, 0xeb, 0x41, 0xd5, 0xfa, 0xfd, 0xa0, 0x6a, 0xfd, 0x7d, 0x50, 0xb5, 0x7e, 0xfa, 0xa7, 0xfa,
	0xde, 0x97, 0x1f, 0x4e, 0xfc, 0x1b, 0x48, 0x53, 0xdc, 0x09, 0x49, 0x44, 0x7a, 0x34, 0x50, 0xa1,
	0xc4, 0x64, 0xac, 0x4e, 0x1e, 0xae, 0xa2, 0x8f, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x6a, 0xd7,
	0xf7, 0x19, 0x9c, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NotebookServiceClient is the client API for NotebookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotebookServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None (authenticated only)
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get on the notebook
	GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create on the deployment
	CreateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*Notebook, error)
	// Delete an existing notebook using its ID.
	// This initially marks the notebook for deletion. It is deleted from CP once all its child resources are deleted.
	// Required permissions:
	// - notebook.notebook.delete on the notebook
	DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Update an existing notebook. Returns updated Notebook.
	// Required permissions:
	// - notebook.notebook.update on the notebook
	UpdateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*v1.Empty, error)
	// List all notebooks for the deployments identified by the given deployment identifier.
	// Required permissions:
	// - notebook.notebook.list on the deployment
	ListNotebooks(ctx context.Context, in *ListNotebooksRequest, opts ...grpc.CallOption) (*NotebookList, error)
	// List all notebook models available in the context of the given deployment.
	// Required permissions:
	// - notebook.model.list globally
	ListNotebookModels(ctx context.Context, in *ListNotebookModelsRequest, opts ...grpc.CallOption) (*NotebookModelList, error)
	// Pauses a running notebook identified by the given id.
	// Required permissions:
	// - notebook.notebook.pause on the notebook
	PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Resumes a paused notebook identified by the given id.
	// When ResumeNotebook is invoked on a notebook that has is_paused not set, an PreconditionFailed error is returned.
	// Required permissions:
	// - notebook.notebook.resume on the notebook
	ResumeNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
}

type notebookServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotebookServiceClient(cc *grpc.ClientConn) NotebookServiceClient {
	return &notebookServiceClient{cc}
}

func (c *notebookServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) GetNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) CreateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*Notebook, error) {
	out := new(Notebook)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) DeleteNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) UpdateNotebook(ctx context.Context, in *Notebook, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/UpdateNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebooks(ctx context.Context, in *ListNotebooksRequest, opts ...grpc.CallOption) (*NotebookList, error) {
	out := new(NotebookList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ListNotebookModels(ctx context.Context, in *ListNotebookModelsRequest, opts ...grpc.CallOption) (*NotebookModelList, error) {
	out := new(NotebookModelList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ListNotebookModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) PauseNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notebookServiceClient) ResumeNotebook(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.notebook.v1.NotebookService/ResumeNotebook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotebookServiceServer is the server API for NotebookService service.
type NotebookServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None (authenticated only)
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Get a Notebook using its ID.
	// Required permissions:
	// - notebook.notebook.get on the notebook
	GetNotebook(context.Context, *v1.IDOptions) (*Notebook, error)
	// Create a new Notebook by specifying its configuration.
	// Required permissions:
	// - notebook.notebook.create on the deployment
	CreateNotebook(context.Context, *Notebook) (*Notebook, error)
	// Delete an existing notebook using its ID.
	// This initially marks the notebook for deletion. It is deleted from CP once all its child resources are deleted.
	// Required permissions:
	// - notebook.notebook.delete on the notebook
	DeleteNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Update an existing notebook. Returns updated Notebook.
	// Required permissions:
	// - notebook.notebook.update on the notebook
	UpdateNotebook(context.Context, *Notebook) (*v1.Empty, error)
	// List all notebooks for the deployments identified by the given deployment identifier.
	// Required permissions:
	// - notebook.notebook.list on the deployment
	ListNotebooks(context.Context, *ListNotebooksRequest) (*NotebookList, error)
	// List all notebook models available in the context of the given deployment.
	// Required permissions:
	// - notebook.model.list globally
	ListNotebookModels(context.Context, *ListNotebookModelsRequest) (*NotebookModelList, error)
	// Pauses a running notebook identified by the given id.
	// Required permissions:
	// - notebook.notebook.pause on the notebook
	PauseNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Resumes a paused notebook identified by the given id.
	// When ResumeNotebook is invoked on a notebook that has is_paused not set, an PreconditionFailed error is returned.
	// Required permissions:
	// - notebook.notebook.resume on the notebook
	ResumeNotebook(context.Context, *v1.IDOptions) (*v1.Empty, error)
}

// UnimplementedNotebookServiceServer can be embedded to have forward compatible implementations.
type UnimplementedNotebookServiceServer struct {
}

func (*UnimplementedNotebookServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedNotebookServiceServer) GetNotebook(ctx context.Context, req *v1.IDOptions) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) CreateNotebook(ctx context.Context, req *Notebook) (*Notebook, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) DeleteNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) UpdateNotebook(ctx context.Context, req *Notebook) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebooks(ctx context.Context, req *ListNotebooksRequest) (*NotebookList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebooks not implemented")
}
func (*UnimplementedNotebookServiceServer) ListNotebookModels(ctx context.Context, req *ListNotebookModelsRequest) (*NotebookModelList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotebookModels not implemented")
}
func (*UnimplementedNotebookServiceServer) PauseNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseNotebook not implemented")
}
func (*UnimplementedNotebookServiceServer) ResumeNotebook(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeNotebook not implemented")
}

func RegisterNotebookServiceServer(s *grpc.Server, srv NotebookServiceServer) {
	s.RegisterService(&_NotebookService_serviceDesc, srv)
}

func _NotebookService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_GetNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).GetNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/GetNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).GetNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_CreateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notebook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/CreateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).CreateNotebook(ctx, req.(*Notebook))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_DeleteNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/DeleteNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).DeleteNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_UpdateNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Notebook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).UpdateNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/UpdateNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).UpdateNotebook(ctx, req.(*Notebook))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebooks(ctx, req.(*ListNotebooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ListNotebookModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotebookModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ListNotebookModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ListNotebookModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ListNotebookModels(ctx, req.(*ListNotebookModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_PauseNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/PauseNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).PauseNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotebookService_ResumeNotebook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotebookServiceServer).ResumeNotebook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.notebook.v1.NotebookService/ResumeNotebook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotebookServiceServer).ResumeNotebook(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotebookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.notebook.v1.NotebookService",
	HandlerType: (*NotebookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _NotebookService_GetAPIVersion_Handler,
		},
		{
			MethodName: "GetNotebook",
			Handler:    _NotebookService_GetNotebook_Handler,
		},
		{
			MethodName: "CreateNotebook",
			Handler:    _NotebookService_CreateNotebook_Handler,
		},
		{
			MethodName: "DeleteNotebook",
			Handler:    _NotebookService_DeleteNotebook_Handler,
		},
		{
			MethodName: "UpdateNotebook",
			Handler:    _NotebookService_UpdateNotebook_Handler,
		},
		{
			MethodName: "ListNotebooks",
			Handler:    _NotebookService_ListNotebooks_Handler,
		},
		{
			MethodName: "ListNotebookModels",
			Handler:    _NotebookService_ListNotebookModels_Handler,
		},
		{
			MethodName: "PauseNotebook",
			Handler:    _NotebookService_PauseNotebook_Handler,
		},
		{
			MethodName: "ResumeNotebook",
			Handler:    _NotebookService_ResumeNotebook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "notebook.proto",
}

func (m *NotebookList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Budget != nil {
		{
			size, err := m.Budget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebooksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebooksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebooksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notebook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notebook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notebook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatedById) > 0 {
		i -= len(m.CreatedById)
		copy(dAtA[i:], m.CreatedById)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.CreatedById)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LastResumedAt != nil {
		{
			size, err := m.LastResumedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LastPausedAt != nil {
		{
			size, err := m.LastPausedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.IsPaused {
		i--
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DiskSize != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NotebookModelId) > 0 {
		i -= len(m.NotebookModelId)
		copy(dAtA[i:], m.NotebookModelId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.NotebookModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinDiskSize != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.MinDiskSize))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxDiskSize != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.MaxDiskSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Memory != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x20
	}
	if m.Cpu != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cpu))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NotebookModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotebookModelList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NotebookModelList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNotebook(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNotebookModelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNotebookModelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNotebookModelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x22
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintNotebook(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status_Usage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_Usage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status_Usage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastCpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuLimit))))
		i--
		dAtA[i] = 0x2d
	}
	if m.LastMemoryLimit != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.LastMemoryLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.LastCpuUsage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuUsage))))
		i--
		dAtA[i] = 0x1d
	}
	if m.LastMemoryUsage != 0 {
		i = encodeVarintNotebook(dAtA, i, uint64(m.LastMemoryUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.DataVolumeInfo != nil {
		{
			size, err := m.DataVolumeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNotebook(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNotebook(dAtA []byte, offset int, v uint64) int {
	offset -= sovNotebook(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NotebookList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.Budget != nil {
		l = m.Budget.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebooksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Notebook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.IsPaused {
		n += 2
	}
	if m.LastPausedAt != nil {
		l = m.LastPausedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastResumedAt != nil {
		l = m.LastResumedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.CreatedById)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NotebookModelId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovNotebook(uint64(m.DiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotebookModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Cpu != 0 {
		n += 5
	}
	if m.Memory != 0 {
		n += 1 + sovNotebook(uint64(m.Memory))
	}
	if m.MaxDiskSize != 0 {
		n += 1 + sovNotebook(uint64(m.MaxDiskSize))
	}
	if m.MinDiskSize != 0 {
		n += 1 + sovNotebook(uint64(m.MinDiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotebookModelList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovNotebook(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNotebookModelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status_Usage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataVolumeInfo != nil {
		l = m.DataVolumeInfo.Size()
		n += 1 + l + sovNotebook(uint64(l))
	}
	if m.LastMemoryUsage != 0 {
		n += 1 + sovNotebook(uint64(m.LastMemoryUsage))
	}
	if m.LastCpuUsage != 0 {
		n += 5
	}
	if m.LastMemoryLimit != 0 {
		n += 1 + sovNotebook(uint64(m.LastMemoryLimit))
	}
	if m.LastCpuLimit != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNotebook(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNotebook(x uint64) (n int) {
	return sovNotebook(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotebookList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Notebook{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Budget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Budget == nil {
				m.Budget = &v1.Budget{}
			}
			if err := m.Budget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebooksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebooksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebooksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notebook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notebook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notebook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPausedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastPausedAt == nil {
				m.LastPausedAt = &types.Timestamp{}
			}
			if err := m.LastPausedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResumedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastResumedAt == nil {
				m.LastResumedAt = &types.Timestamp{}
			}
			if err := m.LastResumedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &ModelSpec{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotebookModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cpu = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiskSize", wireType)
			}
			m.MaxDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDiskSize", wireType)
			}
			m.MinDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotebookModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NotebookModel{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNotebookModelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNotebookModelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNotebookModelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &Status_Usage{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_Usage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Usage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Usage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNotebook
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNotebook
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataVolumeInfo == nil {
				m.DataVolumeInfo = &v11.DataVolumeInfo{}
			}
			if err := m.DataVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryUsage", wireType)
			}
			m.LastMemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuUsage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuUsage = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryLimit", wireType)
			}
			m.LastMemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuLimit = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNotebook(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNotebook
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNotebook(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNotebook
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNotebook
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNotebook
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNotebook
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNotebook
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNotebook        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNotebook          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNotebook = fmt.Errorf("proto: unexpected end of group")
)
