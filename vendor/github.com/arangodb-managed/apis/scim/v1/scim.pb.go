// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scim.proto

package v1

import (
	context "context"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	_ "github.com/arangodb-managed/apis/iam/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// UserName is the schema used for name of user in SCIM API response
type UserName struct {
	// Formatted name string
	Formatted string `protobuf:"bytes,1,opt,name=formatted,proto3" json:"formatted,omitempty"`
	// Given name / first name of user
	GivenName string `protobuf:"bytes,2,opt,name=givenName,proto3" json:"givenName,omitempty"`
	// Family name / last name of the user
	FamilyName           string   `protobuf:"bytes,3,opt,name=familyName,proto3" json:"familyName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserName) Reset()         { *m = UserName{} }
func (m *UserName) String() string { return proto.CompactTextString(m) }
func (*UserName) ProtoMessage()    {}
func (*UserName) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{0}
}
func (m *UserName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserName.Merge(m, src)
}
func (m *UserName) XXX_Size() int {
	return m.Size()
}
func (m *UserName) XXX_DiscardUnknown() {
	xxx_messageInfo_UserName.DiscardUnknown(m)
}

var xxx_messageInfo_UserName proto.InternalMessageInfo

func (m *UserName) GetFormatted() string {
	if m != nil {
		return m.Formatted
	}
	return ""
}

func (m *UserName) GetGivenName() string {
	if m != nil {
		return m.GivenName
	}
	return ""
}

func (m *UserName) GetFamilyName() string {
	if m != nil {
		return m.FamilyName
	}
	return ""
}

// UserResource is the schema used for resource like emails / photos of user in SCIM API response
type UserResource struct {
	// Value of resource example, email address or photo url
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// If set value is used as the primary source of information
	Primary bool `protobuf:"varint,2,opt,name=primary,proto3" json:"primary,omitempty"`
	// Optional value. Sets the type resource example photo
	Type                 string   `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserResource) Reset()         { *m = UserResource{} }
func (m *UserResource) String() string { return proto.CompactTextString(m) }
func (*UserResource) ProtoMessage()    {}
func (*UserResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{1}
}
func (m *UserResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserResource.Merge(m, src)
}
func (m *UserResource) XXX_Size() int {
	return m.Size()
}
func (m *UserResource) XXX_DiscardUnknown() {
	xxx_messageInfo_UserResource.DiscardUnknown(m)
}

var xxx_messageInfo_UserResource proto.InternalMessageInfo

func (m *UserResource) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *UserResource) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *UserResource) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// Metadata is the schema used for meta data of a resource in SCIM API response
type Metadata struct {
	// Identifies type of resource example User / Group
	ResourceType string `protobuf:"bytes,1,opt,name=resourceType,proto3" json:"resourceType,omitempty"`
	// Defines the time at which the resource was created
	Created *types.Timestamp `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// Defines the time at which the resource was updated
	LastModified         *types.Timestamp `protobuf:"bytes,3,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{2}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *Metadata) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Metadata) GetLastModified() *types.Timestamp {
	if m != nil {
		return m.LastModified
	}
	return nil
}

// User is the schema used for user information in SCIM API response
type User struct {
	// Name of schemas followed in request / response
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// User identifier
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Display name of user
	DisplayName string `protobuf:"bytes,3,opt,name=displayName,proto3" json:"displayName,omitempty"`
	// Nick name of user
	NickName string `protobuf:"bytes,4,opt,name=nickName,proto3" json:"nickName,omitempty"`
	// Language preferred by user
	Locale string `protobuf:"bytes,5,opt,name=locale,proto3" json:"locale,omitempty"`
	// Name of user
	Name *UserName `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Emails of user
	Emails []*UserResource `protobuf:"bytes,7,rep,name=emails,proto3" json:"emails,omitempty"`
	// Photos of user
	Photos []*UserResource `protobuf:"bytes,8,rep,name=photos,proto3" json:"photos,omitempty"`
	// Meta information of user creation and updation
	Meta *Metadata `protobuf:"bytes,9,opt,name=meta,proto3" json:"meta,omitempty"`
	// External identifier is used to know the ArangoGraph Insights Platform id
	ExternalId string `protobuf:"bytes,10,opt,name=externalId,proto3" json:"externalId,omitempty"`
	// Check if user is active
	Active bool `protobuf:"varint,11,opt,name=active,proto3" json:"active,omitempty"`
	// userName attribute of the external system like okta
	UserName             string   `protobuf:"bytes,12,opt,name=userName,proto3" json:"userName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{3}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *User) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *User) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *User) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *User) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *User) GetName() *UserName {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *User) GetEmails() []*UserResource {
	if m != nil {
		return m.Emails
	}
	return nil
}

func (m *User) GetPhotos() []*UserResource {
	if m != nil {
		return m.Photos
	}
	return nil
}

func (m *User) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *User) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *User) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *User) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

// Request params for ListUsers
type ListUsersRequest struct {
	// Pagination offset value
	StartIndex int32 `protobuf:"varint,1,opt,name=startIndex,proto3" json:"startIndex,omitempty"`
	// Pagination limit value
	Count int32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Filters to apply for querying data
	Filter               string   `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUsersRequest) Reset()         { *m = ListUsersRequest{} }
func (m *ListUsersRequest) String() string { return proto.CompactTextString(m) }
func (*ListUsersRequest) ProtoMessage()    {}
func (*ListUsersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{4}
}
func (m *ListUsersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsersRequest.Merge(m, src)
}
func (m *ListUsersRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUsersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsersRequest proto.InternalMessageInfo

func (m *ListUsersRequest) GetStartIndex() int32 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *ListUsersRequest) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ListUsersRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Response for ListUsers
type ListUserResponse struct {
	// Name of schemas followed in response
	Schemas []string `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// Total number of results available
	TotalResult int32 `protobuf:"varint,2,opt,name=totalResult,proto3" json:"totalResult,omitempty"`
	// Pagination offset value
	StartIndex int32 `protobuf:"varint,3,opt,name=startIndex,proto3" json:"startIndex,omitempty"`
	// Pagination limit value
	Count int32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	// List of users
	Resources            []*User  `protobuf:"bytes,5,rep,name=Resources,proto3" json:"Resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUserResponse) Reset()         { *m = ListUserResponse{} }
func (m *ListUserResponse) String() string { return proto.CompactTextString(m) }
func (*ListUserResponse) ProtoMessage()    {}
func (*ListUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cc04e339d3d55e6b, []int{5}
}
func (m *ListUserResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserResponse.Merge(m, src)
}
func (m *ListUserResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserResponse proto.InternalMessageInfo

func (m *ListUserResponse) GetSchemas() []string {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *ListUserResponse) GetTotalResult() int32 {
	if m != nil {
		return m.TotalResult
	}
	return 0
}

func (m *ListUserResponse) GetStartIndex() int32 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *ListUserResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ListUserResponse) GetResources() []*User {
	if m != nil {
		return m.Resources
	}
	return nil
}

func init() {
	proto.RegisterType((*UserName)(nil), "arangodb.cloud.resourcemanager.v1.UserName")
	proto.RegisterType((*UserResource)(nil), "arangodb.cloud.resourcemanager.v1.UserResource")
	proto.RegisterType((*Metadata)(nil), "arangodb.cloud.resourcemanager.v1.Metadata")
	proto.RegisterType((*User)(nil), "arangodb.cloud.resourcemanager.v1.User")
	proto.RegisterType((*ListUsersRequest)(nil), "arangodb.cloud.resourcemanager.v1.ListUsersRequest")
	proto.RegisterType((*ListUserResponse)(nil), "arangodb.cloud.resourcemanager.v1.ListUserResponse")
}

func init() { proto.RegisterFile("scim.proto", fileDescriptor_cc04e339d3d55e6b) }

var fileDescriptor_cc04e339d3d55e6b = []byte{
	// 854 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xe4, 0x44,
	0x10, 0xc6, 0x99, 0xff, 0x9a, 0x80, 0x56, 0xad, 0xd5, 0xae, 0xb1, 0xc2, 0xec, 0xac, 0x39, 0x10,
	0x2d, 0x5a, 0x5b, 0x49, 0x38, 0x81, 0x04, 0x5a, 0xd8, 0x28, 0x1a, 0x89, 0x00, 0xf2, 0xee, 0x72,
	0xe0, 0x44, 0xc5, 0xae, 0x99, 0xb4, 0xb0, 0xdd, 0xc6, 0xdd, 0xb6, 0x12, 0x10, 0x97, 0x3d, 0x71,
	0x45, 0x5c, 0x78, 0x00, 0x1e, 0x06, 0x89, 0x0b, 0x12, 0x2f, 0x80, 0x02, 0x67, 0x9e, 0x01, 0x75,
	0xbb, 0x9d, 0x99, 0x04, 0x66, 0x33, 0x20, 0x71, 0x73, 0xfd, 0x7e, 0xf5, 0x7d, 0x55, 0xd3, 0x03,
	0x20, 0x63, 0x9e, 0x05, 0x45, 0x29, 0x94, 0x60, 0xf7, 0xb1, 0xc4, 0x7c, 0x21, 0x92, 0x93, 0x20,
	0x4e, 0x45, 0x95, 0x04, 0x25, 0x49, 0x51, 0x95, 0x31, 0x65, 0x98, 0xe3, 0x82, 0xca, 0xa0, 0xde,
	0xf3, 0xee, 0xc4, 0x22, 0xcb, 0x44, 0x1e, 0xd6, 0x7b, 0x61, 0xf3, 0xd5, 0x94, 0x7a, 0xb7, 0x38,
	0x66, 0xda, 0xc9, 0xd1, 0x36, 0xf3, 0xde, 0x59, 0x70, 0x75, 0x5a, 0x9d, 0x04, 0xb1, 0xc8, 0xc2,
	0x85, 0x48, 0x31, 0x5f, 0x84, 0x26, 0x70, 0x52, 0xcd, 0xc3, 0x42, 0x9d, 0x17, 0x24, 0x43, 0xc5,
	0x33, 0x92, 0x0a, 0xb3, 0x62, 0xf9, 0x65, 0x8b, 0x77, 0x16, 0x42, 0x2c, 0x52, 0x0a, 0xb1, 0xe0,
	0x21, 0xe6, 0xb9, 0x50, 0xa8, 0xb8, 0xc8, 0x65, 0x13, 0xf5, 0xe7, 0x30, 0x7c, 0x26, 0xa9, 0xfc,
	0x08, 0x33, 0x62, 0x3b, 0x30, 0x9a, 0x8b, 0x32, 0x43, 0xa5, 0x28, 0x71, 0x9d, 0xa9, 0xb3, 0x3b,
	0x8a, 0x96, 0x0e, 0x1d, 0x5d, 0xf0, 0x9a, 0x72, 0x9d, 0xea, 0x6e, 0x35, 0xd1, 0x4b, 0x07, 0x9b,
	0x00, 0xcc, 0x31, 0xe3, 0xe9, 0xb9, 0x09, 0x77, 0x4c, 0x78, 0xc5, 0xe3, 0x47, 0xb0, 0xad, 0x71,
	0x22, 0x2b, 0x03, 0xbb, 0x0d, 0xbd, 0x1a, 0xd3, 0x8a, 0x2c, 0x4e, 0x63, 0x30, 0x17, 0x06, 0x45,
	0xc9, 0x33, 0x2c, 0xcf, 0x0d, 0xc2, 0x30, 0x6a, 0x4d, 0xc6, 0xa0, 0xab, 0x89, 0xda, 0xce, 0xe6,
	0xdb, 0xff, 0xd1, 0x81, 0xe1, 0x31, 0x29, 0x4c, 0x50, 0x21, 0xf3, 0x61, 0xbb, 0xd5, 0xf8, 0xa9,
	0x4e, 0x6c, 0xfa, 0x5e, 0xf1, 0xb1, 0xb7, 0x60, 0x10, 0x97, 0x84, 0x9a, 0x9e, 0x6e, 0x3f, 0xde,
	0xf7, 0x82, 0x46, 0x9c, 0xa0, 0x95, 0x33, 0x78, 0xda, 0xaa, 0x17, 0xb5, 0xa9, 0xec, 0x5d, 0xd8,
	0x4e, 0x51, 0xaa, 0x63, 0x91, 0xf0, 0x39, 0xa7, 0xc4, 0x8c, 0xf0, 0xe2, 0xd2, 0x2b, 0xf9, 0xfe,
	0x9f, 0x1d, 0xe8, 0x6a, 0xee, 0x9a, 0x9d, 0x8c, 0x4f, 0x29, 0x43, 0xe9, 0x3a, 0xd3, 0xce, 0xee,
	0x28, 0x6a, 0x4d, 0xf6, 0x0a, 0x6c, 0xf1, 0xc4, 0x8a, 0xba, 0xc5, 0x13, 0x36, 0x85, 0x71, 0xc2,
	0x65, 0x91, 0xe2, 0xaa, 0x9c, 0xab, 0x2e, 0xe6, 0xc1, 0x30, 0xe7, 0xf1, 0x17, 0x26, 0xdc, 0x35,
	0xe1, 0x4b, 0x9b, 0xdd, 0x81, 0x7e, 0x2a, 0x62, 0x4c, 0xc9, 0xed, 0x99, 0x88, 0xb5, 0xd8, 0x7b,
	0xd0, 0xcd, 0x75, 0x7e, 0xdf, 0x10, 0x78, 0x33, 0xb8, 0xf1, 0x44, 0x83, 0xf6, 0x34, 0x22, 0x53,
	0xc8, 0x8e, 0xa0, 0x4f, 0x19, 0xf2, 0x54, 0xba, 0x83, 0x69, 0x67, 0x77, 0xbc, 0x1f, 0x6e, 0xd8,
	0xa2, 0xdd, 0x7a, 0x64, 0xcb, 0x75, 0xa3, 0xe2, 0x54, 0x28, 0x21, 0xdd, 0xe1, 0x7f, 0x6c, 0xd4,
	0x94, 0x6b, 0x4a, 0x19, 0x29, 0x74, 0x47, 0x1b, 0x53, 0x6a, 0x0f, 0x26, 0x32, 0x85, 0xfa, 0x6e,
	0xe9, 0x4c, 0x51, 0x99, 0x63, 0x3a, 0x4b, 0x5c, 0x68, 0xee, 0x76, 0xe9, 0xd1, 0x5a, 0x62, 0xac,
	0x78, 0x4d, 0xee, 0xd8, 0x1c, 0xa4, 0xb5, 0xb4, 0xfe, 0x95, 0x15, 0xc7, 0xdd, 0x6e, 0xf4, 0x6f,
	0x6d, 0xff, 0x73, 0xb8, 0xf5, 0x21, 0x97, 0x4a, 0x0f, 0x2c, 0x23, 0xfa, 0xb2, 0x22, 0xa9, 0x34,
	0x8e, 0x54, 0x58, 0xaa, 0x59, 0x9e, 0xd0, 0x99, 0x39, 0xce, 0x5e, 0xb4, 0xe2, 0xd1, 0xbf, 0x87,
	0x58, 0x54, 0xb9, 0x32, 0x47, 0xd0, 0x8b, 0x1a, 0x43, 0xa3, 0xcf, 0x79, 0xaa, 0xa8, 0xb4, 0x27,
	0x60, 0x2d, 0xff, 0x67, 0x67, 0x09, 0x11, 0x91, 0x2c, 0x44, 0x2e, 0xe9, 0x05, 0xe7, 0x35, 0x85,
	0xb1, 0x12, 0x0a, 0xd3, 0x88, 0x64, 0x95, 0xb6, 0x10, 0xab, 0xae, 0x6b, 0xe3, 0x75, 0xd6, 0x8f,
	0xd7, 0x5d, 0x1d, 0xef, 0x10, 0x46, 0xed, 0x46, 0xa4, 0xdb, 0x33, 0x9b, 0x7c, 0x63, 0xd3, 0x4d,
	0x2e, 0x2b, 0xf7, 0xbf, 0xed, 0xc3, 0xf8, 0xc9, 0x07, 0xb3, 0xe3, 0x27, 0x54, 0xd6, 0x3c, 0x26,
	0x56, 0xc1, 0xcb, 0x47, 0xa4, 0x1e, 0x7d, 0x32, 0xfb, 0x94, 0x4a, 0xc9, 0x45, 0xce, 0xee, 0x5d,
	0x6f, 0x6a, 0xdf, 0xcb, 0x7a, 0x2f, 0x38, 0xcc, 0x0a, 0x75, 0xee, 0xdd, 0x5f, 0x9f, 0x60, 0x7b,
	0xf8, 0xd3, 0xe7, 0xbf, 0xfe, 0xf1, 0xfd, 0x96, 0xc7, 0x5c, 0xf3, 0x10, 0xea, 0x97, 0x5a, 0xbf,
	0xb1, 0x58, 0xf0, 0x87, 0xb5, 0x45, 0xf9, 0xce, 0x81, 0xd1, 0xe5, 0xde, 0xd8, 0xc1, 0x06, 0x44,
	0xae, 0x6f, 0xd9, 0xfb, 0x37, 0x45, 0xed, 0xde, 0x7c, 0xcf, 0x4c, 0x76, 0x9b, 0xb1, 0x2b, 0x93,
	0x35, 0x53, 0x9c, 0xc1, 0xe0, 0x88, 0x4c, 0x3a, 0x7b, 0x7d, 0x3d, 0xc7, 0xd9, 0xe3, 0x8f, 0x0b,
	0xf3, 0xa8, 0x7b, 0x9b, 0xca, 0xef, 0xdf, 0x33, 0xa0, 0xaf, 0xb2, 0xbb, 0x7f, 0x07, 0x0d, 0xbf,
	0xe6, 0xc9, 0x37, 0xec, 0x2b, 0x18, 0x3c, 0x4a, 0x12, 0x83, 0xbc, 0x69, 0xd3, 0xcd, 0xd1, 0x5f,
	0x33, 0xe8, 0x77, 0xfd, 0x7f, 0xa0, 0xfc, 0xb6, 0xf3, 0x80, 0x3d, 0x77, 0x00, 0x9e, 0x15, 0x09,
	0x2a, 0xfa, 0x9f, 0xf0, 0x7d, 0x83, 0xbf, 0xe3, 0xad, 0x63, 0xaf, 0x87, 0x90, 0x00, 0x8f, 0x29,
	0x25, 0x3b, 0xc3, 0x46, 0xea, 0xdf, 0x74, 0xa7, 0xad, 0xea, 0x0f, 0xd6, 0xe1, 0xbe, 0x7f, 0xf8,
	0xd3, 0xc5, 0xc4, 0xf9, 0xe5, 0x62, 0xe2, 0xfc, 0x76, 0x31, 0x71, 0x7e, 0xf8, 0x7d, 0xf2, 0xd2,
	0x67, 0x07, 0x2b, 0xff, 0xfd, 0x6d, 0xf7, 0x87, 0x0d, 0x9f, 0x44, 0x77, 0x91, 0xe1, 0x35, 0x92,
	0x61, 0xbd, 0x77, 0xd2, 0x37, 0x7f, 0x4a, 0x07, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0xa3, 0xe8,
	0x8d, 0x7f, 0x92, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SCIMServiceClient is the client API for SCIMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SCIMServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None (authenticated only)
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// List the users as per SCIM API requirements
	// For an organization identifier inferred via API Key
	// Required permissions:
	// - scim.user.list on the organization
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUserResponse, error)
	// Get the organization member information based on user identifier as per SCIM API requirements
	// Required permissions:
	// - scim.user.get on the organization
	GetUser(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*User, error)
	// Invite the user to an organization
	// that is inferred from API key
	// Required permissions:
	// - scim.user.add on the organization
	AddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Update the user information
	// Required permissions:
	// - scim.user.update on the organization
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error)
	// Delete the user from an organization
	// Required permissions:
	// - scim.user.delete on the organization
	DeleteUser(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
}

type sCIMServiceClient struct {
	cc *grpc.ClientConn
}

func NewSCIMServiceClient(cc *grpc.ClientConn) SCIMServiceClient {
	return &sCIMServiceClient{cc}
}

func (c *sCIMServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCIMServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUserResponse, error) {
	out := new(ListUserResponse)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/ListUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCIMServiceClient) GetUser(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCIMServiceClient) AddUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/AddUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCIMServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCIMServiceClient) DeleteUser(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.resourcemanager.v1.SCIMService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SCIMServiceServer is the server API for SCIMService service.
type SCIMServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None (authenticated only)
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// List the users as per SCIM API requirements
	// For an organization identifier inferred via API Key
	// Required permissions:
	// - scim.user.list on the organization
	ListUsers(context.Context, *ListUsersRequest) (*ListUserResponse, error)
	// Get the organization member information based on user identifier as per SCIM API requirements
	// Required permissions:
	// - scim.user.get on the organization
	GetUser(context.Context, *v1.IDOptions) (*User, error)
	// Invite the user to an organization
	// that is inferred from API key
	// Required permissions:
	// - scim.user.add on the organization
	AddUser(context.Context, *User) (*User, error)
	// Update the user information
	// Required permissions:
	// - scim.user.update on the organization
	UpdateUser(context.Context, *User) (*User, error)
	// Delete the user from an organization
	// Required permissions:
	// - scim.user.delete on the organization
	DeleteUser(context.Context, *v1.IDOptions) (*v1.Empty, error)
}

// UnimplementedSCIMServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSCIMServiceServer struct {
}

func (*UnimplementedSCIMServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedSCIMServiceServer) ListUsers(ctx context.Context, req *ListUsersRequest) (*ListUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (*UnimplementedSCIMServiceServer) GetUser(ctx context.Context, req *v1.IDOptions) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (*UnimplementedSCIMServiceServer) AddUser(ctx context.Context, req *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUser not implemented")
}
func (*UnimplementedSCIMServiceServer) UpdateUser(ctx context.Context, req *User) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (*UnimplementedSCIMServiceServer) DeleteUser(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}

func RegisterSCIMServiceServer(s *grpc.Server, srv SCIMServiceServer) {
	s.RegisterService(&_SCIMService_serviceDesc, srv)
}

func _SCIMService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCIMService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCIMService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).GetUser(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCIMService_AddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).AddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/AddUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).AddUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCIMService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCIMService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCIMServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.resourcemanager.v1.SCIMService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCIMServiceServer).DeleteUser(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCIMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.resourcemanager.v1.SCIMService",
	HandlerType: (*SCIMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _SCIMService_GetAPIVersion_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _SCIMService_ListUsers_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _SCIMService_GetUser_Handler,
		},
		{
			MethodName: "AddUser",
			Handler:    _SCIMService_AddUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _SCIMService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _SCIMService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scim.proto",
}

func (m *UserName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FamilyName) > 0 {
		i -= len(m.FamilyName)
		copy(dAtA[i:], m.FamilyName)
		i = encodeVarintScim(dAtA, i, uint64(len(m.FamilyName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GivenName) > 0 {
		i -= len(m.GivenName)
		copy(dAtA[i:], m.GivenName)
		i = encodeVarintScim(dAtA, i, uint64(len(m.GivenName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Formatted) > 0 {
		i -= len(m.Formatted)
		copy(dAtA[i:], m.Formatted)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Formatted)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastModified != nil {
		{
			size, err := m.LastModified.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintScim(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintScim(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x62
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintScim(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Photos) > 0 {
		for iNdEx := len(m.Photos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Photos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Emails) > 0 {
		for iNdEx := len(m.Emails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Name != nil {
		{
			size, err := m.Name.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScim(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Locale) > 0 {
		i -= len(m.Locale)
		copy(dAtA[i:], m.Locale)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Locale)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NickName) > 0 {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintScim(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintScim(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintScim(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintScim(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintScim(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.StartIndex != 0 {
		i = encodeVarintScim(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListUserResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScim(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Count != 0 {
		i = encodeVarintScim(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.StartIndex != 0 {
		i = encodeVarintScim(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalResult != 0 {
		i = encodeVarintScim(dAtA, i, uint64(m.TotalResult))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Schemas[iNdEx])
			copy(dAtA[i:], m.Schemas[iNdEx])
			i = encodeVarintScim(dAtA, i, uint64(len(m.Schemas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintScim(dAtA []byte, offset int, v uint64) int {
	offset -= sovScim(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Formatted)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.GivenName)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovScim(uint64(l))
	}
	if m.LastModified != nil {
		l = m.LastModified.Size()
		n += 1 + l + sovScim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovScim(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovScim(uint64(l))
	}
	if len(m.Emails) > 0 {
		for _, e := range m.Emails {
			l = e.Size()
			n += 1 + l + sovScim(uint64(l))
		}
	}
	if len(m.Photos) > 0 {
		for _, e := range m.Photos {
			l = e.Size()
			n += 1 + l + sovScim(uint64(l))
		}
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovScim(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUsersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartIndex != 0 {
		n += 1 + sovScim(uint64(m.StartIndex))
	}
	if m.Count != 0 {
		n += 1 + sovScim(uint64(m.Count))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovScim(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for _, s := range m.Schemas {
			l = len(s)
			n += 1 + l + sovScim(uint64(l))
		}
	}
	if m.TotalResult != 0 {
		n += 1 + sovScim(uint64(m.TotalResult))
	}
	if m.StartIndex != 0 {
		n += 1 + sovScim(uint64(m.StartIndex))
	}
	if m.Count != 0 {
		n += 1 + sovScim(uint64(m.Count))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovScim(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovScim(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScim(x uint64) (n int) {
	return sovScim(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Formatted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastModified == nil {
				m.LastModified = &types.Timestamp{}
			}
			if err := m.LastModified.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &UserName{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emails = append(m.Emails, &UserResource{})
			if err := m.Emails[len(m.Emails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photos = append(m.Photos, &UserResource{})
			if err := m.Photos[len(m.Photos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScim
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResult", wireType)
			}
			m.TotalResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalResult |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScim
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScim
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScim
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &User{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScim(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScim
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScim(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScim
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScim
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScim
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScim
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScim
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScim        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScim          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScim = fmt.Errorf("proto: unexpected end of group")
)
